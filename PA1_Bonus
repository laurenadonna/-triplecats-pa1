#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/epoll.h>
#include <sys/socket.h>
#include <pthread.h>
#include <errno.h>

#define MAX_EVENTS 64
#define MESSAGE_SIZE 16
#define MAX_WORKER_THREADS 4  // Number of worker threads
#define BACKLOG 128           // Max pending connections

char *server_ip = "127.0.0.1";
int server_port = 12345;

// Structure to manage worker threads
typedef struct {
    int client_fd;
} work_item_t;

work_item_t work_queue[BACKLOG];
int queue_front = 0, queue_rear = 0, queue_size = 0;
pthread_mutex_t queue_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t queue_cond = PTHREAD_COND_INITIALIZER;

//Add client to the queue
void enqueue_work(int client_fd) {
    pthread_mutex_lock(&queue_mutex);

    if (queue_size < BACKLOG) {
        work_queue[queue_rear].client_fd = client_fd;
        queue_rear = (queue_rear + 1) % BACKLOG;
        queue_size++;
        pthread_cond_signal(&queue_cond);
    } else {
        printf("Server: Work queue is full! Dropping connection.\n");
        close(client_fd);
    }

    pthread_mutex_unlock(&queue_mutex);
}

//Get a client from the queue
int dequeue_work() {
    pthread_mutex_lock(&queue_mutex);

    while (queue_size == 0) {
        pthread_cond_wait(&queue_cond, &queue_mutex);
    }

    int client_fd = work_queue[queue_front].client_fd;
    queue_front = (queue_front + 1) % BACKLOG;
    queue_size--;

    pthread_mutex_unlock(&queue_mutex);
    return client_fd;
}

//Worker function for processing clients
void *worker_thread_func(void *arg) {
    char buf[MESSAGE_SIZE];

    while (1) {
        int client_fd = dequeue_work();

        while (1) {
            int bytes_read = recv(client_fd, buf, MESSAGE_SIZE, 0);
            if (bytes_read <= 0) {
                printf("Worker: Closing client connection.\n");
                close(client_fd);
                break;
            }

            printf("Worker: Received message '%s'\n", buf);
            send(client_fd, buf, bytes_read, 0);
        }
    }

    return NULL;
}

//Start worker threads
void start_worker_threads(pthread_t *workers, int num_threads) {
    for (int i = 0; i < num_threads; i++) {
        pthread_create(&workers[i], NULL, worker_thread_func, NULL);
    }
}

//Run the multi-threaded server
void run_server() {
    int listen_fd, epoll_fd;
    struct epoll_event event, events[MAX_EVENTS];
    struct sockaddr_in server_addr;
    int tr = 1;

    //Create worker threads
    pthread_t workers[MAX_WORKER_THREADS];
    start_worker_threads(workers, MAX_WORKER_THREADS);

    //Create listening socket
    listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd < 0) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }
    if (setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &tr, sizeof(int)) == -1) {
        perror("Error, setsockopt");
        exit(EXIT_FAILURE);
    }

    //Bind socket to IP and port
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr(server_ip);
    server_addr.sin_port = htons(server_port);

    if (bind(listen_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("Bind failed");
        close(listen_fd);
        exit(EXIT_FAILURE);
    }

    //Listen for incoming connections
    if (listen(listen_fd, BACKLOG) < 0) {
        perror("Listen failed");
        close(listen_fd);
        exit(EXIT_FAILURE);
    }

    // Create epoll instance
    epoll_fd = epoll_create1(0);
    if (epoll_fd < 0) {
        perror("Epoll creation failed");
        close(listen_fd);
        exit(EXIT_FAILURE);
    }

    //Register listening socket with epoll
    event.events = EPOLLIN;
    event.data.fd = listen_fd;
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &event) < 0) {
        perror("Epoll control failed");
        close(listen_fd);
        close(epoll_fd);
        exit(EXIT_FAILURE);
    }

    printf("Server is running on %s:%d...\n", server_ip, server_port);

    //Server's event loop
    while (1) {
        int n = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
        if (n < 0) {
            if (errno == EINTR) continue;
            perror("Epoll wait failed");
            break;
        }

        for (int i = 0; i < n; i++) {
            if (events[i].data.fd == listen_fd) {
                // Accept new connection
                int client_fd = accept(listen_fd, NULL, NULL);
                if (client_fd < 0) {
                    perror("Accept failed");
                    continue;
                }

                printf("Server: Accepted new connection.\n");

                // Assign to a worker thread
                enqueue_work(client_fd);
            }
        }
    }

    //Clean up
    close(listen_fd);
    close(epoll_fd);
    printf("Server stopped gracefully.\n");
}

//Main function
int main(int argc, char *argv[]) {
    if (argc > 1 && strcmp(argv[1], "server") == 0) {
        if (argc > 2) server_ip = argv[2];
        if (argc > 3) server_port = atoi(argv[3]);

        run_server();
    } else {
        printf("Usage: %s server [server_ip server_port]\n", argv[0]);
    }

    return 0;
}
